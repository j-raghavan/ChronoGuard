# Template for TLS certificates
# Copy this file to tls-secrets.yaml and fill in your actual base64-encoded certificates
# DO NOT commit the filled-in secrets file to version control!
#
# To generate base64-encoded certificates:
# cat /path/to/server-cert.pem | base64 -w 0
# cat /path/to/server-key.pem | base64 -w 0
# cat /path/to/ca-cert.pem | base64 -w 0

apiVersion: v1
kind: Secret
metadata:
  name: chronoguard-tls-secret
  namespace: chronoguard
  labels:
    app.kubernetes.io/name: chronoguard
    app.kubernetes.io/component: proxy
type: Opaque
data:
  # Envoy server certificate (PEM format, base64-encoded)
  # This certificate is presented to agents connecting to the proxy
  server-cert.pem: <BASE64_ENCODED_SERVER_CERT>

  # Envoy server private key (PEM format, base64-encoded)
  # Keep this secret secure!
  server-key.pem: <BASE64_ENCODED_SERVER_KEY>

  # CA certificate for validating agent client certificates (PEM format, base64-encoded)
  # This CA must have signed the agent client certificates
  ca-cert.pem: <BASE64_ENCODED_CA_CERT>

---
# Alternative: Use stringData for non-encoded values (Kubernetes will encode them automatically)
# Uncomment and use this format if you prefer to paste PEM content directly:
#
# apiVersion: v1
# kind: Secret
# metadata:
#   name: chronoguard-tls-secret
#   namespace: chronoguard
#   labels:
#     app.kubernetes.io/name: chronoguard
#     app.kubernetes.io/component: proxy
# type: Opaque
# stringData:
#   server-cert.pem: |
#     -----BEGIN CERTIFICATE-----
#     <YOUR_SERVER_CERT_CONTENT_HERE>
#     -----END CERTIFICATE-----
#   server-key.pem: |
#     -----BEGIN PRIVATE KEY-----
#     <YOUR_SERVER_KEY_CONTENT_HERE>
#     -----END PRIVATE KEY-----
#   ca-cert.pem: |
#     -----BEGIN CERTIFICATE-----
#     <YOUR_CA_CERT_CONTENT_HERE>
#     -----END CERTIFICATE-----
